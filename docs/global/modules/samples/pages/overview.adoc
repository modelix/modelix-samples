= Overview of the samples
:navtitle: Overview
// Temporary redirect to no break links in modelix.docs documentation.
:page-aliases: reference/architecture.adoc

The samples are structured into use cases.
Each use case uses different components from the modelix platform
to create custom solutions.

On this page, you can get an overview of all use cases,
and see how they are related and what their essential differences are.

image::system-diagram-full.svg[]

[#use_case_1]
== Use case 1

In the first use case, an MPS project is synchronized to a repository on a xref:core:reference/component-model-server.adoc[model server]
by utilizing the https://artifacts.itemis.cloud/service/rest/repository/browse/maven-mps/org/modelix/mps/model-server-sync-plugin/[model-server-sync-plugin].

It shows how to make model data, previously accessible only in a running MPS or via files, available through a server.

In itself, this use case has little value, but the next use cases build in part on it.

See the xref:use_case_1.adoc[Use case 1 page] for details.

[#use_case_2]
== Use case 2

In this use case, we connect web frontends to a xref:core:reference/component-model-server.adoc[model server].
The web frontends read from and write model data to the model server.

One web frontend can be used to edit model data and is implemented with Vue.js.
The other one serves as an overview and is implemented with Angular.

You can see
how changes made in one connected application are instantly reflected in another connected application.
You can also connect an MPS to the model server
and see how changes made in the application are synced to MPS and vice versa.

The frontend applications directly use the https://artifacts.itemis.cloud/service/rest/repository/browse/npm-open/%40modelix/model-client/[model-client] JavaScript library
that connects to the model server.
They also use a TypeScript API
generated by the xref:core:reference/component-model-api-gen-gradle.adoc[Model API generator] from the xref:metamodel.adoc[metamodel]
to enable type-safe access to data structures provided by the model client.

See the xref:use_case_2.adoc[Use case 2 page] for details.


[#use_case_3]
== Use case 3

In this use case, a web frontend connects to a web backend,
which in turn communicates with a xref:core:reference/component-model-server.adoc[model server].

Like in xref:use_case_2[use case 2] model data is synced automatically between the model server, the application and MPS.

A backend is needed if you need to control what data a client might read and write.
It is also useful to translate data from modelix data structures into a data structure that is suitable for your web applications.

The web backend is implemented with https://quarkus.io/[Quarkus].
It uses the https://artifacts.itemis.cloud/service/rest/repository/browse/maven-mps/org/modelix/model-client/[model-client]
to connect to a model server.
It also uses a Kotlin API
generated by the xref:core:reference/component-model-api-gen-gradle.adoc[Model API generator] from the xref:metamodel.adoc[metamodel]
to enable type-safe access to data structures provided by the model client.

For the Angular based web frontend, the web backend provides a custom HTTP-
and websocket-based API.

See the xref:use_case_3.adoc[Use case 3 page] for details.

// === Use case 4
//
// WARNING: asdf
//
// The web backend in this variant is implemented with https://ktor.io[Ktor].
// It uses the xref:core:reference/component-light-model-client.adoc[light-model-client] to connect to a running MPS
// that exposes its data through the xref:core:reference/component-mps-model-server-plugin.adoc[model-server-plugin].
//

[#monitoring]
== Monitoring the `model-server`

This is not strictly a use case but rather a bonus to increase the transparency and visibility of the requests happening in the background.
xref:core:howto/metrics.adoc[The `model-server` always provides a `/metrics`
endpoint] which allows you to obtain data on several inner workings, such as HTTP connections or JVM statistics.
As soon as you start a `model-server`, you can thus run a dedicated monitoring database (e.g. Prometheus) and a dashboard (e.g. Grafana) to obtain and visualize metrics respectively.


See the xref:monitoring.adoc[Monitoring page] for details.
